<!DOCTYPE html>

<html>

<head>
    <Title>|INK Incorporated presents INK Inc|</Title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
</head>
<body>

<h1>
    <p style="text-align:center;"><input id="myInkLevel"></p>
</h1>

<script>

    var config = {
        type: Phaser.AUTO,
        width: 1300,
        height: 800,
        backgroundColor: '#ffffff',
        physics: {
            default: 'arcade',
        },

        scene: {
            preload: preload,
            create: create,
            update: update,
        }

    };

    var game = new Phaser.Game(config);
    //constants
    const LEFT = 'left';
    const RIGHT = 'right';
    const UP = 'up';
    const DOWN = 'down';
    const ROCK = 'rock';
    //Game Objects
    var inkSpots;
    var mapTiles;
    var rocks;
    var sdoors; //size doors, not key doors
    var player;
    var collectibles;
    var objects;

    //impassable objects
    var barriers = [];

    //backup in case color-wall detection is bad
    //passable objects, but has a wall on the [direction] side
    //based off New Ink Inc Tileset
    var leftWalls = [];
    var rightWalls = [];
    var upWalls = [];
    var downWalls = [];

    var levels = [];
    //var door = [];


    //inkMap[posY][posX]
    var inkMap = new Array(10);


    for (let i = 0; i < inkMap.length; i++) {
        inkMap[i] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }



    //Keyboard controls
    var cursors;
    var space;
    var keyA, keyD, keyW, keyS;

    var graphics;

    function preload() {
        this.load.image('inkBlob', 'inkblob/InkBlob.png');
        this.load.image('inkSpot', 'levels/InkSploch.png')
        this.load.image('inkedTile', 'levels/InkedTile.png');
        this.load.image('greenTile', 'levels/GreenTile.png')
        this.load.image('rock', 'levels/boulder.png');
        /*

        */
        //let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'sky').setOrigin(0, 0);
        //this.load.tilemapTiledJSON('tilemap', "texture.json");
        //this.load.image('whiteTile', 'levels/WhiteTile.png');
    }


    function create() {
        //Set the background origin to be at (0, 0) or top left corner of the image rather than the center of the image asset
        //we dont have one

        //create all animations
        //this.anims.create({key: 'inkBlob', frames: this.anims.generateFrameNames('seacreatures', {prefix: 'blueJellyfish', end: 32, zeroPad: 4}), repeat: -1});
        var test = new Array(10);
        for (let i = 0; i < test.length; i++) {
            test[i] = new Array(10);
            for (let j = 0; j < test[i].length; j++) {
                test[i][j] = i + ' ' + j;

            }
        }
        console.log(toString(test))
        mapTiles = new Array(10);
        for (let i = 0; i < mapTiles.length; i++) {
            mapTiles[i] = new Array(10);
            for (let j = 0; j < mapTiles[i].length; j++) {
                mapTiles[i][j] = this.add.image(j * 80 + 40, i * 80 + 40, 'greenTile')

            }
        }
        inkSpots = new Array(10);
        for (let i = 0; i < inkSpots.length; i++) {
            inkSpots[i] = new Array(10);
            for (let j = 0; j < inkSpots[i].length; j++) {
                inkSpots[i][j] = this.add.image(j * 80 + 40, i * 80 + 40, 'inkSpot')
                inkSpots[i][j].visible = false;
            }
        }
        rocks = new Array(0);
        rocks.push(new Rock(this, 5, 1, 1));
        console.log("done with init1")


        createMap(0);

        //player = new Player(this, 400, 400, 'slime', playerAnimations);
        player = new Player(this, 0, 0, 'inkBlob', null);
        //player.play(player.animations['idle']);

        //Set up user input
        cursors = this.input.keyboard.createCursorKeys();
        keyA = this.input.keyboard.addKey('A');
        keyD = this.input.keyboard.addKey('D');
        keyW = this.input.keyboard.addKey('W');
        keyS = this.input.keyboard.addKey('S');
        space = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

        keyA.on('down', move);
        keyD.on('down', move);
        keyW.on('down', move);
        keyS.on('down', move);

        graphics = this.add.graphics();
        console.log("done with create")
        update()
    }

    /*
    class Door {

    }

     */


    class Player extends Phaser.Physics.Arcade.Sprite {
        animations;
        inkLevel = 15;
        //document.getElementById("myInkLevel").value = this.inkLevel;
        //posX is the 0 based index of the inkblob in the map
        //x is the pixel position on the screen
        posX = 0;
        posY = 0;

        constructor(scene, posX, posY, spritesheet, animations) {
            super(scene, posX * 80 + 40, posY * 80 + 40, spritesheet);
            this.animations = animations;
            scene.add.existing(this);
            this.setScale(0.5);
        }
    }

    class Tile {
        type;
        isLeftWall;
        isRightWall;
        isUpWall;
        isDownWall;
        isWall;
        image;
        constructor(type) {
            //stuff lmao
            //also we hopefully wont have to do this
            //like the tilemap should place it for us
            //hopefully
        }
    }

    //like rocks and buttons and bottles
    //we could just do a 2d array
    //like
    //we can do object.isMovable or something
    //good point
    //let objects[][];
    //then a 0 is nothing, 1 is button, 2 is rock, 3 is bottle
    class Obj extends Phaser.Physics.Arcade.Sprite {
        type;
        movable;
        posX;
        posY;
        image;
        constructor(type, scene, posX, posY, image, movable) {
            super(scene, posX * 80 + 40, posY * 80 + 40, image);
            this.type = type;
            this.posX = posX;
            this.posY = posY;
            this.movable = movable;
            scene.add.existing(this);
        }
        //why not? object.movable is the same good point
        //couldnt we do a while function so if u are big enough to move the rock it is movable but if ur too small it doesnt move
        //in a subclass
        //like we extend teh object class

    }

    class Rock extends Obj{
        size;
        constructor (scene, size, posX, posY) {
            super('rock', scene, posX, posY, 'rock', true);
            this.size = size;
            console.log('create rock size:' + this.size + ' at ' + posX + ', ' + posY);
        }
        /* eliah's version
        push(posXChange, posYChange){
            if (player.inkLevel >= this.size){
                this.posX += posXChange;
                this.posY += posYChange;
                this.image.posX += posXChange * 80;
                this.image.posY += posYChange * 80;
                //check if run into a wall later
                //right
            }
            checking if the player was too small (do better later, just a waiting thing) else if (player.inkLevel < this.size || (collided with wall)){
                player.posX -= posXChange;
                player.posY -= posYChange;
                player.x -= posXChange * 80;
                player.y -= posYChange * 80;
                this.posX -= posXChange;
                this.posY -= posYChange;
                this.image.posX -= posXChange * 80;
                this.image.posY -= posYChange * 80;
            }

            console.log("pushed: x: " + player.x + ", " + player.y);
        }
         */
        //weight refers to total rock weight
        pushRock(direction) {
            let totalWeight = 0;
            let targetRocks = new Array(0);
            console.log('pushRock called: X: ' + this.posX + ", Y: " + this.posY)
            if (direction === LEFT) {
                let tempX = this.posX;
                while (isValidPos(tempX, this.posY) && isRock(tempX, this.posY)) {
                    let rock = getRock(tempX, this.posY)
                    totalWeight += rock.size
                    targetRocks.push(rock);
                    tempX--;
                }
                if (player.inkLevel >= totalWeight && isValidPos(tempX, this.posY)) {
                    for (let i = targetRocks.length - 1; i >= 0; i--) {
                        targetRocks[i].posX -= 1;
                        targetRocks[i].x -= 80;
                    }
                    console.log('left true')
                    return true;
                } else {
                    console.log('left false')
                    return false;
                }
            } else if (direction === RIGHT) {
                let tempX = this.posX;
                while (isValidPos(tempX, this.posY) && isRock(tempX, this.posY)) {
                    let rock = getRock(tempX, this.posY)
                    totalWeight += rock.size
                    targetRocks.push(rock);
                    tempX++;
                }
                if (player.inkLevel >= totalWeight && isValidPos(tempX, this.posY)) {
                    for (let i = targetRocks.length - 1; i >= 0; i--) {
                        targetRocks[i].posX += 1;
                        targetRocks[i].x += 80;
                    }
                    console.log('right true')
                    return true;
                } else {
                    console.log('right false')
                    return false;
                }
            } else if (direction === UP) {
                let tempY = this.posY;
                while (isValidPos(this.posX, tempY) && isRock(this.posX, tempY)) {
                    let rock = getRock(this.posX, tempY)
                    totalWeight += rock.size
                    targetRocks.push(rock);
                    tempY--;
                }
                if (player.inkLevel >= totalWeight && isValidPos(this.posX, tempY)) {
                    for (let i = targetRocks.length - 1; i >= 0; i--) {
                        targetRocks[i].posY -= 1;
                        targetRocks[i].y -= 80;
                    }
                    console.log('up true')
                    return true;
                } else {
                    console.log('up false')
                    return false;
                }
            } else if (direction === DOWN) {
                let tempY = this.posY;
                while (isValidPos(this.posX, tempY) && isRock(this.posX, tempY)) {
                    let rock = getRock(this.posX, tempY)
                    totalWeight += rock.size
                    targetRocks.push(rock);
                    tempY++;
                }
                if (player.inkLevel >= totalWeight && isValidPos(this.posX, tempY)) {
                    for (let i = targetRocks.length - 1; i >= 0; i--) {
                        targetRocks[i].posY += 1;
                        targetRocks[i].y += 80;
                    }
                    console.log('down true')
                    return true;
                } else {
                    console.log('down false')
                    return false;
                }
            }
        }
    }

    class Level {
        constructor(scene, layout, startingInk, startX, startY, objects, collectibles, levelNum) {
            player.inkLevel = startingInk;
            player.x = startX * 80;
            player.y = startY * 80;
            player.posX = startX;
            player.posY = startY;
        }
    }
    //creates each level layout based on the level id
    function createMap(id) {

    }

    function update() {

    }

    function move() {
        //Handle player movements
        let prevX = player.posX;
        let prevY = player.posY;
        //if the blob actually moves, moved is set to true
        let moved = false;
        //direction moved, for rock checks
        //let diMoveX;
        //let diMoveY;
        let direction;
        if ((player.inkLevel <= 0 && inkMap[player.posX][player.posY]===0))
        {
            console.log('No ink left to grab or move.');
            return;
        }
        //direction = DOWN;
        //objects[player.posY][player.posX-1].push(direction);
        //console.log('should have pushed down')
        if (isValidPos(prevX - 1, prevY) && keyA.isDown && !keyD.isDown && !keyW.isDown && !keyS.isDown) {
            direction = LEFT
            console.log('left pressed');
            if (isRock(player.posX-1, player.posY) && getRock(player.posX-1, player.posY).pushRock(direction)
                || !hasObject(player.posX-1, player.posY))
                /* || (objects[player.posY][player.posX-1].type === 'sDoor' && player.inkLevel <= objects(player.posY][player.posX-1].size)*/{
                console.log('left push should have been called');
                player.x -= 80;
                player.posX -= 1;
                moved = true;
            }
        } else if (isValidPos(prevX + 1, prevY) && !keyA.isDown && keyD.isDown && !keyW.isDown && !keyS.isDown) {
            direction = 'right'
            console.log('right pressed');
            if (isRock(player.posX+1, player.posY) && getRock(player.posX+1, player.posY).pushRock(direction)
                || !hasObject(player.posX+1, player.posY)) {
                console.log('right push should have been called');
                player.x += 80;
                player.posX += 1;
                moved = true;
            }
        } else if (isValidPos(prevX, prevY - 1) && !keyA.isDown && !keyD.isDown && keyW.isDown && !keyS.isDown) {
            direction = 'up'
            console.log('up pressed');
            if (isRock(player.posX, player.posY-1) && getRock(player.posX, player.posY-1).pushRock(direction)
                || !hasObject(player.posX, player.posY-1)) {
                console.log('up push should have been called');
                player.y -= 80;
                player.posY -= 1;
                moved = true;
            }
        } else if (isValidPos(prevX, prevY + 1) && !keyA.isDown && !keyD.isDown && !keyW.isDown && keyS.isDown) {
            direction = 'down';
            console.log('down pressed');
            if (isRock(player.posX, player.posY+1) && getRock(player.posX, player.posY+1).pushRock(direction)
                || !hasObject(player.posX, player.posY+1)) {
                console.log('down push should have been called');
                player.y += 80;
                player.posY += 1;
                moved = true;
            }
        }
        console.log(prevX + "," + prevY + " to " + player.posX + "," + player.posY);
        console.log('about to leave or pick up ink');
        if (moved) {
            //ink code
            console.log(player.inkLevel);
            if (inkMap[prevY][prevX] === 0) {
                player.inkLevel--;
                inkMap[prevY][prevX] = 1;
            } else if (inkMap[prevY][prevX] === 1) {
                player.inkLevel++;
                inkMap[prevY][prevX] = 0;
            }
            console.log('finished with the ink, starting rock check');
            //rock code
            /* eliah's version
            for (let i = 0; i < rocks.length; i++){
                console.log('rock: ' + rocks[i].size)
                if (player.posX === rocks[i].posX && player.posY === rocks[i].posY){
                    rocks[i].push(diMoveX, diMoveY);
                }
            }

             */
            //michael's version (done above)
        }
        console.log(toString(inkMap));
        for (let i = 0; i < 10; i++) {
            for (let j = 0; j < 10; j++) {
                if (inkMap[i][j] === 1) {
                    inkSpots[i][j].visible = true;
                } else if (inkMap[i][j] === 0) {
                    inkSpots[i][j].visible = false;
                }
            }
        }
        if (player.inkLevel <= 0) {

            console.log('YOU LOSE');
        }
        //update()
    }


    /*class Tilestate{
        let clean[][];
        let dirty[][];




    }
    */
    function toString(inkMap) {
        var result = "";
        for (let i of inkMap) {
            result += "[" + i + "], \n";
        }
        return result;
    }
    function getRock(posX, posY) {
        for (let rock of rocks) {
            if (rock.posX === posX && rock.posY === posY) {
                return rock;
            }
        }
        return null;
    }
    function isRock(posX, posY){
        return getRock(posX, posY) !== null;
    }
    function hasObject(posX, posY) {
        return getRock(posX, posY) !== null;
        //|| door || ink etc.
    }
    /*
    function getsDoor(posX, posY) {
        for (let sdoor of sdoors) {
            if (sdoor.posX === posX && sdoor.posY === posY) {
                return sdoor;
            }
        }
        return null;
    }
    function issDoor(posX, posY){
        return getsDoor(posX, posY) !== null;
    }*/
var col
    function isValidPos(posX, posY) {
        //console.log(this.textures.getPixel(posX*80, posY*80));
        return posX >= 0 && posX < 10 && posY >= 0 && posY < 10 /*&& this.textures.getPixel(posX*80, posY*80) !== #24664d*/;
    }
    function isWall(posX1, posY1, posX2, posY2) {
        let isX = true;
        if (posX1 === posX2) {
            let min = Math.min(posY1, posY2);
            let max = posY1 + posY2 - min;
            isX = false;
            //lmao
        } else if (posY1 === posY2) {
            let min = Math.min(posX1, posX2);
            let max = posX1 + posX2 - min;

        }
        /*for (let i = 0; i<(max-min);  i++){
            if (isX){
                




         */
    }
</script>

</body>

</html>
