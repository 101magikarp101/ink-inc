<!DOCTYPE html>

<html>

<head>
    <Title>|INK Incorporated presents INK Inc|</Title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

</head>
<body>

<script>
    var config = {
        type: Phaser.AUTO,
        width: 1300,
        height: 800,
        backgroundColor: '#ffffff',
        physics: {
            default: 'arcade',
        },

        scene: {
            preload: preload,
            create: create,
            update: update,
        }

    };

    var game = new Phaser.Game(config);
    //constants
    const LEFT = 'left';
    const RIGHT = 'right';
    const UP = 'up';
    const DOWN = 'down';
    const ROCK = 'rock';
    var WALLCOLOR;
    //Game Objects
    var inkSpots;
    var rocks;
    var sdoors; //size doors, not key doors
    var bdoors;
    var buttons;
    var inkWells;
    var player;
    var playerInk;
    var goal;
    var numLevels = 7; //if the first level is level 0

    var levels = new Array(9);
    var curLev = 8;
    const STARTX = [0, 0, 2, 0, 1, 1, 0, 0, 0];
    const STARTY = [4, 4, 4, 4, 2, 2, 0, 0, 0];
    //size, x, y
    var ROCKS =
        [
        [],
        [],
        [],
        [],
        [[7, 8, 4]],
        [[8, 8, 4]],
        [],
        [[15, 1, 2]],
        [[15, 8, 3]]
    ];
    //size, posx, posy, direction
    var SDOORS =
        [
        [],
        [],
        [],
        [[12, 8, 4, 'leftRight']],
        [],
        [],
        [[3, 2, 1, 'upDown'], [7, 3, 9, 'leftRight']],
        [[3, 8, 0, 'leftRight']],
        [[8, 6, 0, 'leftRight']]
    ];

    //x and y
    var BDOORS =
        [
        [],
        [[6, 4, false, 'leftRight']],
        [[2, 2, false, 'upDown']],
        [],
        [],
        [],
        [],
        [[7, 0, false, 'leftRight']],
        []
        ];
    //x, y, index of corresponding bdoor ([a][b])
    var BUTTONS =
        [
            [],
            [[4, 4, 1, 0]],
            [[7, 1, 2, 0]],
            [],
            [],
            [],
            [],
            [[2, 3, 7, 0]],
            [],
        ];
    //ink, posX, posY
    var INKWELLS =
        [
        [],
        [],
        [],
        [],
        [],
        [],
        [[7, 4, 0], [5, 1, 3], [5, 2, 3], [2, 9, 5], [4, 4, 6], [3, 1, 8]],
        [[8, 4, 5]],
        []
    ];
    const GOALX = [3, 9, 2, 9, 9, 9, 2, 9, 9];
    const GOALY = [6, 4, 1, 4, 4, 4, 0, 0, 3];
    const STARTINGINK = [20, 10, 9, 25, 15, 15, 15, 12, 25];//not counting some inkwells cus idk the values and we using this to calc start ink



    var _this;
    //inkMap[posY][posX]
    var inkMap = new Array(10);


    for (let i = 0; i < inkMap.length; i++) {
        inkMap[i] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }



    //Keyboard controls
    var cursors;
    var space;
    var keyA, keyD, keyW, keyS, keyR;

    var graphics;

    function preload() {
        this.load.image('inkBlobL', 'inkblob/InkBlobLeft.png');
        this.load.image('inkBlobR', 'inkblob/InkBlobRight.png');
        this.load.image('inkBlobU', 'inkblob/InkBlobUp.png');
        this.load.image('inkBlobD', 'inkblob/InkBlobDown.png');
        this.load.image('inkSpot', 'levels/InkSploch.png');
        this.load.image('greenTile', 'levels/GreenTile.png')
        this.load.image('rock', 'objects/Boulder.png');
        this.load.image('sDoorH', 'objects/SDoorHorizontal.png');
        this.load.image('sDoorV', 'objects/SDoorVertical.png');
        this.load.image('inkWell', 'objects/InkWell.png');
        this.load.image('bDoorOH', 'objects/BDoorOpenHorizontal.png');
        this.load.image('bDoorOV', 'objects/BDoorOpenVertical.png');
        this.load.image('bDoorCH', 'objects/BDoorClosedHorizontal.png');
        this.load.image('bDoorCV', 'objects/BDoorClosedVertical.png');
        this.load.image('button', 'objects/Button.png');
        this.load.image('level0', 'levels/Level1.png');
        this.load.image('level1', 'levels/Level2.png');
        this.load.image('level2', 'levels/Level3.png');
        this.load.image('level3', 'levels/Level4.png');
        this.load.image('level4', 'levels/Level5.png');
        this.load.image('level5', 'levels/Level5.png');
        this.load.image('level6', 'levels/Level6.png');
        this.load.image('level7', 'levels/Level7.png');
        this.load.image('level8', 'levels/Level8.png');

        //let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'sky').setOrigin(0, 0);
        //this.load.tilemapTiledJSON('tilemap', "texture.json");
        //this.load.image('whiteTile', 'levels/WhiteTile.png');
    }


    function create() {
        //Set the background origin to be at (0, 0) or top left corner of the image rather than the center of the image asset
        //we dont have one
        _this = this;
        //create all animations
        //this.anims.create({key: 'inkBlob', frames: this.anims.generateFrameNames('seacreatures', {prefix: 'blueJellyfish', end: 32, zeroPad: 4}), repeat: -1});



        //player = new Player(this, 400, 400, 'slime', playerAnimations);

        //player.play(player.animations['idle']);

        levels = new Array(0);
        //for (let i = 0; i < 8; i++) {
            //instead of this for loop, just make a new level whenever curLev changes with curLev instead of I
        //}
        //
        makeLevel();
        WALLCOLOR = _this.textures.getPixel(0, 0, 'greenTile');
        //player = new Player(this, levels[curLev].startX, levels[curLev].startY, 'inkBlob', null);
        //player.inkLevel = levels[curLev].inkLevel;
        console.log('Finished most of creation');
        //Set up user input
        cursors = _this.input.keyboard.createCursorKeys();
        keyA = _this.input.keyboard.addKey('A');
        keyD = _this.input.keyboard.addKey('D');
        keyW = _this.input.keyboard.addKey('W');
        keyS = _this.input.keyboard.addKey('S');
        keyR = _this.input.keyboard.addKey('R');
        space = _this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

        keyA.on('down', move);
        keyD.on('down', move);
        keyW.on('down', move);
        keyS.on('down', move);
        keyR.on('down', makeLevel);

        graphics = this.add.graphics();
        console.log("done with create")
        update()
    }

    /*
    class Door {

    }

     */

    class Player extends Phaser.Physics.Arcade.Sprite {
        animations;
        inkLevel = 15;
        //document.getElementById("myInkLevel").value = this.inkLevel;
        //posX is the 0 based index of the inkblob in the map
        //x is the pixel position on the screen
        posX;
        posY;
        orientation = DOWN;
        constructor(scene, posX, posY, spritesheet, animations) {
            super(scene, posX * 80 + 40, posY * 80 + 40, spritesheet);
            this.animations = animations;
            this.posX = posX;
            this.posY = posY;
            this.updateOrientation(DOWN);
            scene.add.existing(this);
            this.setScale(0.5);
        }
        updateOrientation (direction) {
            this.orientation = direction;
            let addon;
            if (direction === DOWN){
                addon = 'D';
            } else if (direction === RIGHT){
                addon = 'R';
            } else if (direction === LEFT){
                addon = 'L';
            } else if (direction === UP){
                addon = 'U';
            }
            this.setTexture('inkBlob' + addon);
        }
    }
    class Level {
        levelNum;
        startingInk;
        image;
        rocks;
        sdoors;
        bdoors;
        inkWells;
        buttons;
        goalX;
        goalY;
        startX;
        startY;
        constructor(scene, startingInk, startX, startY, rocks, sdoors, bdoors, inkWells, buttons, goalX, goalY, levelNum) {
            _this.add.image(400, 400, scene)
            this.startingInk = startingInk;
            this.startX = startX;
            this.startY = startY;
            this.levelNum = levelNum;
            this.goalX = goalX;
            this.goalY = goalY;
            this.image = scene;
            //this.bitmap = new BitmapData(this);
            //starting to fill out rocks, sdoors, buttons, inkwells, etc
            this.rocks = new Array(0);
            //size, x, y
            for (let rock of ROCKS[curLev]) {
                this.rocks.push(new Rock(_this, rock[0], rock[1], rock[2]));
            }
            this.sdoors = new Array(0);
            //size, x, y, direction
            for (let sdoor of SDOORS[curLev]) {
                this.sdoors.push(new SDoor(_this, sdoor[0], sdoor[1], sdoor[2], sdoor[3]));
            }
            this.bdoors = new Array(0);
            //x, y
            for (let bdoor of BDOORS[curLev]) {
                this.bdoors.push(new BDoor(_this, bdoor[0], bdoor[1], bdoor[2], bdoor[3]));
            }
            this.buttons = new Array(0);
            //x, y, arrayPos of connected bDoor
            for (let button of BUTTONS[curLev]) {
                this.buttons.push(new Button(_this, button[0], button[1], this.bdoors[button[3]]));
            }
            this.inkWells = new Array(0);
            //ink, x, y
            for (let inkWell of INKWELLS[curLev]) {
                this.inkWells.push(new InkWell(_this, inkWell[0], inkWell[1], inkWell[2]));
            }
        }
    }
    function makeLevel() {
        //forces them back to empty, in case they weren't already
        rocks = null;
        sdoors = null;
        buttons = null;
        bdoors = null;
        inkSpots = null;
        inkMap = null;
        let tempLev = new Level('level' + curLev, STARTINGINK[curLev], STARTX[curLev], STARTY[curLev], ROCKS[curLev], SDOORS[curLev], BDOORS[curLev], INKWELLS[curLev], BUTTONS[curLev], GOALX[curLev], GOALY[curLev], curLev);
        levels[curLev] = tempLev;
        console.log('level ' + curLev + ' made');
        console.log(tempLev);
        console.log("done with init1 loading current level");
        inkMap = new Array(10);
        for (let i = 0; i < inkMap.length; i++) {
            inkMap[i] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        //inkMap = [
        //        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        //        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        //        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        //        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        //       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        //        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        //        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        //        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        //        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        //        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        //        ];
        inkSpots = new Array(10);
        for (let i = 0; i < inkSpots.length; i++) {
            inkSpots[i] = new Array(10);
            for (let j = 0; j < inkSpots[i].length; j++) {
                inkSpots[i][j] = _this.add.image(j * 80 + 40, i * 80 + 40, 'inkSpot')
                inkSpots[i][j].visible = false;
            }
        }
        player = new Player(_this, levels[curLev].startX, levels[curLev].startY, 'inkBlob', null);
        //player.posX = levels[curLev].startX;
        //player.posY = levels[curLev].startY;
        //player.x = levels[curLev].startX * 80 + 40;
        //player.y = levels[curLev].startY * 80 + 40;
        player.inkLevel = levels[curLev].startingInk;
        console.log('finished init 2 player creation');
        playerInk = _this.add.text(player.x - 10, player.y - 10, '' + player.inkLevel, {font:'bold 15px Arial', fill: '#ffffff'});
        playerInk.text = levels[curLev].inkLevel;
        rocks = levels[curLev].rocks;
        console.log("done with init4, rocks");
        sdoors = levels[curLev].sdoors;
        bdoors = levels[curLev].bdoors;
        inkWells = levels[curLev].inkWells;
        buttons = levels[curLev].buttons;
        console.log("done with init5, sdoors");
    //}
    }
    //like rocks and buttons and bottles
    //we could just do a 2d array
    //like
    //we can do object.isMovable or something
    //good point
    //let objects[][];
    //then a 0 is nothing, 1 is button, 2 is rock, 3 is bottle
    class Obj extends Phaser.Physics.Arcade.Sprite {
        type;
        movable;
        posX;
        posY;
        image;
        constructor(type, scene, posX, posY, image, movable) {
            console.log('recieved image ' + image + ' for a new Obj and Object');
            super(scene, posX * 80 + 40, posY * 80 + 40, image);
            this.type = type;
            this.posX = posX;
            this.posY = posY;
            this.movable = movable;
            scene.add.existing(this);
        }
        //why not? object.movable is the same good point
        //couldnt we do a while function so if u are big enough to move the rock it is movable but if ur too small it doesnt move
        //in a subclass
        //like we extend teh object class

    }

    class Rock extends Obj{
        size;
        text;
        constructor (scene, size, posX, posY) {
            super('rock', scene, posX, posY, 'rock', true);
            this.size = size;
            console.log('create rock size:' + this.size + ' at ' + posX + ', ' + posY);
            this.text = _this.add.text(this.posX * 80 + 30, this.posY * 80 + 20, '' + this.size, {font:'bold 32px Arial', fill: '#abdcff'});
        }
        /* eliah's version
        push(posXChange, posYChange){
            if (player.inkLevel >= this.size){
                this.posX += posXChange;
                this.posY += posYChange;
                this.image.posX += posXChange * 80;
                this.image.posY += posYChange * 80;
                //check if run into a wall later
                //right
            }
            checking if the player was too small (do better later, just a waiting thing) else if (player.inkLevel < this.size || (collided with wall)){
                player.posX -= posXChange;
                player.posY -= posYChange;
                player.x -= posXChange * 80;
                player.y -= posYChange * 80;
                this.posX -= posXChange;
                this.posY -= posYChange;
                this.image.posX -= posXChange * 80;
                this.image.posY -= posYChange * 80;
            }

            console.log("pushed: x: " + player.x + ", " + player.y);
        }
         */
        //weight refers to total rock weight
        pushRock(direction) {
            let totalWeight = 0;
            let targetRocks = new Array(0);
            console.log('pushRock called: X: ' + this.posX + ", Y: " + this.posY)
            if (direction === LEFT) {
                let tempX = this.posX;
                while (isValidPos(tempX, this.posY) && isRock(tempX, this.posY) && !isThruWall(this.posX, this.posY, this.posX - 1, this.posY)) {
                    let rock = getRock(tempX, this.posY)
                    totalWeight += rock.size
                    targetRocks.push(rock);
                    tempX--;
                }
                if (player.inkLevel >= totalWeight && isValidPos(tempX, this.posY) && !isThruWall(this.posX, this.posY, this.posX - 1, this.posY)) {
                    for (let i = targetRocks.length - 1; i >= 0; i--) {
                        targetRocks[i].posX -= 1;
                        targetRocks[i].x -= 80;
                        //targetRocks[i].text.x -= 80;
                    }
                    console.log('left true')
                    return true;
                } else {
                    console.log('left false')
                    return false;
                }
            } else if (direction === RIGHT) {
                let tempX = this.posX;
                while (isValidPos(tempX, this.posY) && isRock(tempX, this.posY) && !isThruWall(this.posX, this.posY, this.posX + 1, this.posY)) {
                    let rock = getRock(tempX, this.posY)
                    totalWeight += rock.size
                    targetRocks.push(rock);
                    tempX++;
                }
                if (player.inkLevel >= totalWeight && isValidPos(tempX, this.posY) && !isThruWall(this.posX, this.posY, this.posX + 1, this.posY)) {
                    for (let i = targetRocks.length - 1; i >= 0; i--) {
                        targetRocks[i].posX += 1;
                        targetRocks[i].x += 80;
                        //targetRocks[i].text.x += 80;
                    }
                    console.log('right true')
                    return true;
                } else {
                    console.log('right false')
                    return false;
                }
            } else if (direction === UP) {
                let tempY = this.posY;
                while (isValidPos(this.posX, tempY) && isRock(this.posX, tempY) && !isThruWall(this.posX, this.posY, this.posX, this.posY - 1)) {
                    let rock = getRock(this.posX, tempY)
                    totalWeight += rock.size
                    targetRocks.push(rock);
                    tempY--;
                }
                if (player.inkLevel >= totalWeight && isValidPos(this.posX, tempY) && !isThruWall(this.posX, this.posY, this.posX, this.posY - 1)) {
                    for (let i = targetRocks.length - 1; i >= 0; i--) {
                        targetRocks[i].posY -= 1;
                        targetRocks[i].y -= 80;
                        //targetRocks[i].text.y -= 80;
                    }
                    console.log('up true')
                    return true;
                } else {
                    console.log('up false')
                    return false;
                }
            } else if (direction === DOWN) {
                let tempY = this.posY;
                while (isValidPos(this.posX, tempY) && isRock(this.posX, tempY) && !isThruWall(this.posX, this.posY, this.posX, this.posY + 1)) {
                    let rock = getRock(this.posX, tempY)
                    totalWeight += rock.size
                    targetRocks.push(rock);
                    tempY++;
                }
                if (player.inkLevel >= totalWeight && isValidPos(this.posX, tempY) && !isThruWall(this.posX, this.posY, this.posX, this.posY + 1)) {
                    for (let i = targetRocks.length - 1; i >= 0; i--) {
                        targetRocks[i].posY += 1;
                        targetRocks[i].y += 80;
                        //targetRocks[i].text.y += 80;
                    }
                    console.log('down true')
                    return true;
                } else {
                    console.log('down false')
                    return false;
                }
            }
        }
    }
    class SDoor extends Obj{
        size;
        //leftRight or upDown
        orientation;
        text;
        constructor(scene, size, posX, posY, orientation) {
            super('sDoor', scene, posX, posY, 'sDoor' + (orientation === 'leftRight'? 'H' : 'V'), false);
            this.size = size;
            this.orientation = orientation;
            console.log('create door with size:' + this.size + ' at ' + posX + ', ' + posY);
            this.text = _this.add.text(posX * 80 + 32, posY * 80 + 15, this.size, {font:'bold 15px Arial', fill: '#000000'});
            this.text.fontWeight = 'bold';
        }
        canThruSdoor(direction){
            console.log('canThruSdoor called');
            if ((direction === DOWN || direction === UP) && this.orientation === 'upDown'){
                return player.inkLevel <= this.size;
            } else if ((direction === LEFT || direction === RIGHT) && this.orientation === 'leftRight'){
                return player.inkLevel <= this.size;
            }
            return false;
        }
    }
    class InkWell extends Obj{
        ink;
        text;
        constructor(scene, ink, posX, posY) {
            super('inkWell', scene, posX, posY, 'inkWell', false);
            this.ink = ink;
            console.log('create inkWell with ink: ' + this.ink)
            this.text = _this.add.text(posX * 80 + 30, posY * 80 + 20, this.ink, {font:'bold 20px Arial', fill: '#ffffff'});
            this.text.fontWeight = 'bold';
        }
        collect() {
            player.inkLevel += this.ink;
            console.log('inkCollected: +' + this.ink + " ink")
            this.ink = 0;
            this.visible = false;
            this.text.visible = false;
            /*
            for (let i = 0; i < inkWells.length; i++) {
                if (this === inkWells[i]) {
                    inkWells.splice(i, 1);
                }
            }

             */
        }
    }
    class Button extends Obj{
        linkedDoor;
        pressed;
        constructor(scene, posX, posY, linkedDoor) {
            super('button', scene, posX, posY, 'button', false);
            this.linkedDoor = linkedDoor;
            console.log('create button' + ' at: ' + posX + ', ' + posY + ' with connected door ' + linkedDoor);
            this.pressed = false;
        }
        updateButton(){
            this.pressed = (inkMap[this.posY][this.posX] === 1);
            if(this.pressed){
                this.linkedDoor.opener(true);
                console.log('door opened: ' + this.linkedDoor)
            } else {
                this.linkedDoor.opener(false);
                console.log('door closed: ' + this.linkedDoor)
            }
        }
    }

    class BDoor extends Obj{
        opened;
        orientation;
        constructor(scene, posX, posY, opened, orientation) {
            //if (opened){
            //    this.superr += 'O';
            //}
            //if (orientation === 'leftRight')
            super('bDoor', scene, posX, posY, 'bDoor' + (opened ? 'O' : 'C') + (orientation === 'leftRight' ? 'H' : 'V'), false);
            this.opened = opened;
            this.orientation = orientation;
            console.log('create button door at ' + posX + ', ' + posY);
        }
        opener(opened){
            this.opened = opened;
            this.image = 'bDoor' + (this.opened ? 'O' : 'C') + (this.orientation === 'leftRight' ? 'H' : 'V');
            this.setTexture('bDoor' + (this.opened ? 'O' : 'C') + (this.orientation === 'leftRight' ? 'H' : 'V'));
        }
        canThruBdoor(direction){
            console.log('canThruBdoor called');
            if ((direction === DOWN || direction === UP) && this.orientation === 'upDown'){
                return this.opened;
            } else if ((direction === LEFT || direction === RIGHT) && this.orientation === 'leftRight'){
                return this.opened;
            }
            return false;
        }

    }

    function update() {

    }

    function move() {
        //Handle player movements
        let prevX = player.posX;
        let prevY = player.posY;
        //if the blob actually moves, moved is set to true
        let moved = false;
        //direction moved, for rock checks
        //let diMoveX;
        //let diMoveY;
        let direction;
        if ((player.inkLevel <= 0 && inkMap[player.posY][player.posX]!== 1))
        {
            console.log('No ink left to grab or move.');
            return;
        }
        //direction = DOWN;
        //objects[player.posY][player.posX-1].push(direction);
        //console.log('should have pushed down')
        if (isValidPos(prevX - 1, prevY) && keyA.isDown && !keyD.isDown && !keyW.isDown && !keyS.isDown && !isThruWall(prevX, prevY, prevX - 1, prevY)) {
            direction = LEFT
            console.log('left pressed');
            if (isRock(player.posX-1, player.posY) && getRock(player.posX-1, player.posY).pushRock(direction))
                /* || (objects[player.posY][player.posX-1].type === 'sDoor' && player.inkLevel <= objects(player.posY][player.posX-1].size)*/{
                console.log('left push should have been called');
                player.x -= 80;
                player.posX -= 1;
                moved = true;
            } else if (isSdoor(player.posX-1, player.posY) && getSdoor(player.posX-1, player.posY).canThruSdoor(direction)) {
                player.x -= 80;
                player.posX -= 1;
                console.log('moving thru door: x: ' + player.posX + ', y: ' + player.posY);
                moved = true;
            } else if (isBdoor(player.posX-1, player.posY) && getBdoor(player.posX-1, player.posY).canThruBdoor(direction)) {
                player.x -= 80;
                player.posX -= 1;
                console.log('moving thru bdoor: x: ' + player.posX + ', y: ' + player.posY);
                moved = true;
            } else if (!hasObject(player.posX-1, player.posY)){
                player.x -= 80;
                player.posX -= 1;
                moved = true;
            }
        } else if (isValidPos(prevX + 1, prevY) && !keyA.isDown && keyD.isDown && !keyW.isDown && !keyS.isDown && !isThruWall(prevX, prevY, prevX + 1, prevY)) {
            direction = 'right'
            console.log('right pressed');
            if (isRock(player.posX+1, player.posY) && getRock(player.posX+1, player.posY).pushRock(direction)) {
                console.log('right push should have been called');
                player.x += 80;
                player.posX += 1;
                moved = true;
            } else if (isSdoor(player.posX+1, player.posY) && getSdoor(player.posX+1, player.posY).canThruSdoor(direction)) {
                player.x += 80;
                player.posX += 1;
                console.log('moving thru door: x: ' + player.posX + ', y: ' + player.posY);
                moved = true;
            } else if (isBdoor(player.posX+1, player.posY) && getBdoor(player.posX+1, player.posY).canThruBdoor(direction)) {
                player.x += 80;
                player.posX += 1;
                console.log('moving thru bdoor: x: ' + player.posX + ', y: ' + player.posY);
                moved = true;
            } else if (!hasObject(player.posX+1, player.posY)){
                player.x += 80;
                player.posX += 1;
                moved = true;
            }
        } else if (isValidPos(prevX, prevY - 1) && !keyA.isDown && !keyD.isDown && keyW.isDown && !keyS.isDown && !isThruWall(prevX, prevY, prevX, prevY - 1)) {
            direction = 'up'
            console.log('up pressed');
            if (isRock(player.posX, player.posY-1) && getRock(player.posX, player.posY-1).pushRock(direction)) {
                console.log('up push should have been called');
                player.y -= 80;
                player.posY -= 1;
                moved = true;
            } else if (isSdoor(player.posX, player.posY-1) && getSdoor(player.posX, player.posY-1).canThruSdoor(direction)) {
                player.y -= 80;
                player.posY -= 1;
                console.log('moving thru door: x: ' + player.posX + ', y: ' + player.posY);
                moved = true;
            } else if (isBdoor(player.posX, player.posY-1) && getBdoor(player.posX, player.posY-1).canThruBdoor(direction)) {
                player.y -= 80;
                player.posY -= 1;
                console.log('moving thru bdoor: x: ' + player.posX + ', y: ' + player.posY);
                moved = true;
            } else if (!hasObject(player.posX, player.posY-1)){
                player.y -= 80;
                player.posY -= 1;
                moved = true;
            }
        } else if (isValidPos(prevX, prevY + 1) && !keyA.isDown && !keyD.isDown && !keyW.isDown && keyS.isDown && !isThruWall(prevX, prevY, prevX, prevY + 1)) {
            direction = 'down';
            console.log('down pressed');
            if (isRock(player.posX, player.posY+1) && getRock(player.posX, player.posY+1).pushRock(direction)) {
                console.log('down push should have been called');
                player.y += 80;
                player.posY += 1;
                moved = true;
            } else if (isSdoor(player.posX, player.posY+1) && getSdoor(player.posX, player.posY+1).canThruSdoor(direction)) {
                player.y += 80;
                player.posY += 1;
                console.log('moving thru door: x: ' + player.posX + ', y: ' + player.posY);
                moved = true;
            } else if (isBdoor(player.posX, player.posY+1) && getBdoor(player.posX, player.posY+1).canThruBdoor(direction)) {
                player.y += 80;
                player.posY += 1;
                console.log('moving thru bdoor: x: ' + player.posX + ', y: ' + player.posY);
                moved = true;
            } else if (!hasObject(player.posX, player.posY+1)){
                player.y += 80;
                player.posY += 1;
                moved = true;
            }
        }
        console.log(prevX + "," + prevY + " to " + player.posX + "," + player.posY);
        console.log('about to leave or pick up ink');
        if (moved) {
            //the player ink tracker

            //ink code
            console.log(player.inkLevel);
            if (inkMap[prevY][prevX] === 0) {
                player.inkLevel--;
                inkMap[prevY][prevX] = 1;
            } else if (inkMap[prevY][prevX] === 1) {
                player.inkLevel++;
                inkMap[prevY][prevX] = 0;
            }
            for (let button of buttons) {
                button.updateButton();
            }
            if (isInkWell(player.posX, player.posY)) {
                getInkWell(player.posX, player.posY).collect();
            }
            playerInk.setPosition(player.x - 10, player.y - 10);
            for (var rock of rocks){
                rock.text.setPosition(rock.posX * 80 + 30, rock.posY * 80 + 20);
            }
            playerInk.text = player.inkLevel;
            player.updateOrientation(direction);
            console.log('finished with the ink, starting rock check');
            /*
            if (buttons.length > 0 && prevX === buttons[0].posX && prevY === buttons[0].posY){
                buttons[0].pressButton();
            }

             */
        }
        console.log(toString(inkMap));
        for (let i = 0; i < 10; i++) {
            for (let j = 0; j < 10; j++) {
                if (inkMap[i][j] === 1) {
                    inkSpots[i][j].visible = true;
                } else if (inkMap[i][j] === 0) {
                    inkSpots[i][j].visible = false;
                }
            }
        }
        //win
        if (player.posY === levels[curLev].goalY && player.posX === levels[curLev].goalX){
            console.log('YOU WIN LEVEL ' + curLev);
            curLev++;
            if (curLev === 9) {
                //win screen
            } else {
                makeLevel();
            }
        }
        else if (player.inkLevel <= 0 && inkMap[player.posY][player.posX] !== 1) {
            console.log('YOU LOSE');
        }
        //update()
    }


    /*class Tilestate{
        let clean[][];
        let dirty[][];




    }
    */
    function toString(inkMap) {
        var result = "";
        for (let i of inkMap) {
            result += "[" + i + "], \n";
        }
        return result;
    }
    function getRock(posX, posY) {
        for (let rock of rocks) {
            if (rock.posX === posX && rock.posY === posY) {
                return rock;
            }
        }
        return null;
    }
    function getSdoor(posX, posY) {
        for (let sdoor of sdoors) {
            if (sdoor.posX === posX && sdoor.posY === posY) {
                return sdoor;
            }
        }
        return null;
    }
    function getBdoor(posX, posY) {
        for (let bdoor of bdoors) {
            if (bdoor.posX === posX && bdoor.posY === posY) {
                return bdoor;
            }
        }
        return null;
    }
    function getInkWell(posX, posY) {
        for (let inkWell of inkWells) {
            if (inkWell.posX === posX && inkWell.posY === posY) {
                return inkWell;
            }
        }
        return null;
    }
    function isRock(posX, posY){
        return getRock(posX, posY) !== null;
    }
    function isSdoor(posX, posY){
        return getSdoor(posX, posY) !== null;
    }
    function isBdoor(posX, posY){
        return getBdoor(posX, posY) !== null;
    }
    function isInkWell(posX, posY) {
        return getInkWell(posX, posY) !== null;
    }
    function hasObject(posX, posY) {
        return getRock(posX, posY) !== null || getSdoor(posX, posY) !== null || getBdoor(posX, posY) !== null;
        //|| door || ink etc.
    }
    /*
    function getsDoor(posX, posY) {
        for (let sdoor of sdoors) {
            if (sdoor.posX === posX && sdoor.posY === posY) {
                return sdoor;
            }
        }
        return null;
    }
    function issDoor(posX, posY){
        return getsDoor(posX, posY) !== null;
    }*/
    function isValidPos(posX, posY) {
        return posX >= 0 && posX < 10 && posY >= 0 && posY < 10 && !isSolidWall(posX, posY);
    }
    /*


    * */
    function isSolidWall(posX, posY) {
        let col;
        col = _this.textures.getPixel(posX*80+40, posY*80+40, levels[curLev].image);
        console.log('col is ' + col + ' in isSolidWall');
        if (col !== null){
            let cout = (Phaser.Display.Color.ComponentToHex(col.r) + Phaser.Display.Color.ComponentToHex(col.g) + Phaser.Display.Color.ComponentToHex(col.b));
            return cout === '24664d';
        } else {
            console.log('isSolidWall is broken');
        }
    }
    function isThruWall(posX1, posY1, posX2, posY2) {
        let min;
        let max;
        posX1 *= 80;
        posX2 *= 80;
        posY1 *= 80;
        posY2 *= 80;
        if (posX1 === posX2) {
            min = Math.min(posY1, posY2);
            max = posY1 + posY2 - min;
            console.log('Y diff: min: ' + min + ', max: ' + max)
            for (let i = 0; i<4; i++) {
                if (isColor(posX1 + 40, min + 78 + i, WALLCOLOR)) {
                    return true;
                }
            }
        } else if (posY1 === posY2) {
            min = Math.min(posX1, posX2);
            max = posX1 + posX2 - min;
            console.log('X diff: min: ' + min + ', max: ' + max)
            for (let i = 0; i<4; i++) {
                if (isColor(min + 78 + i, posY1 + 40, WALLCOLOR)){
                    return true;
                }
            }
        }
        return false;
    }
    function isColor(x, y, color){
        let pix = _this.textures.getPixel(x, y, levels[curLev].image);
        console.log(pix)
        console.log(color)
        var result = (color.r === pix.r && color.g === pix.g && color.b === pix.b);
        console.log('checking color: x: ' + x +', y: ' + y + ', result: ' + result)
        return result/*Phaser.Display.Color.ComponentToHex(_this.textures.getPixel(x+40, y+40, levels[curLev].image)*/;
    }
</script>

</body>

</html>
